<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>작업의 수명(소리내어 읽어봅시다)</title>
  <link rel="icon" href="path/to/favicon.ico" type="image/x-icon">

  <style>
    /* Font import using a corrected format */
    @import url("https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.8/dist/web/static/pretendard-dynamic-subset.css");
    @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,100;1,100&display=swap');

    body {
      margin: 20px 100px;
      overflow-y: hidden;
      text-align: center;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(50, 1fr);
      grid-template-rows: repeat(7, 1fr);
      gap: 0px;
      overflow: hidden;
    }

    .cell {
      width: 1fr;
      height: calc(6px + (70vw - 320px) / 17);
      background-color: rgb(255, 255, 255);
      cursor: pointer;
      display: flex;
      justify-content: top;
      font-size: calc(6px + (70vw - 320px) / 100);
      text-align: center;
      color: white;
      overflow: hidden;
      font-family: 'pretendard';
    }

    #timer {
      height: 110px;
      font-family: 'Roboto Mono', monospace;
      font-size: 150px;
      line-height: 120px;
      margin-bottom: calc(10vw / 2);
    }

    @media screen and (max-width: 640px) {
      .grid {
        display: grid;
        grid-template-columns: repeat(100, 1fr);
        grid-template-rows: repeat(6, 1fr);
        text-align: center;
        overflow: hidden;
        margin: 0%;
      }

      .cell {
        width: 1fr / 2;
        height: calc(6px + (50vw - 120px) / 15);
        font-size: calc(3px + (65vw - 120px) / 100);
        overflow: hidden;
      }

      #timer {
        height: 150px;
        font-family: 'Roboto Mono', monospace;
        font-size: calc(90px + (70vw - 320px) / 100);
        text-align: center;
        line-height: 120px;
        margin-bottom: calc(10vw / 7);
      }
    }
  </style>
</head>

<body>
  <div id="timer">0</div>

  <div class="grid" id="grid">
    <div class="cell" style="grid-column: 1 / 100; grid-row: 1 / 7;"></div>
  </div>

  <script>
    const ROWCOUNT = 7;
    const COLCOUNT = 50;
    let charArrayIdx = new Array(ROWCOUNT * COLCOUNT);
    let whiteCellCount = 0;
    let totalCharCount = 0;
    let isFirstClick = true;
    let baseColor = 'rgb(102,255,102)';
    let midColor = 'rgb(255,255,255)';
    let lastColor = 'rgb(0,0,255)';

    function getCellPosition(cell) {
      const index = Array.from(grid.children).indexOf(cell);
      return [Math.floor(index / COLCOUNT), index % COLCOUNT];
    }

    function getDistance(cell1, cell2) {
      const rect1 = cell1.getBoundingClientRect();
      const rect2 = cell2.getBoundingClientRect();
      return Math.sqrt(Math.pow(rect1.left - rect2.left, 2) + Math.pow(rect1.top - rect2.top, 2));
    }

    function getRandomDuration() {
      return Math.floor(Math.random() * 1000) + 1000;
    }

    const grid = document.getElementById('grid');
    function changeColor(cell, seconds, mode) {
      if (whiteCellCount >= totalCharCount) return;

      cell.style.backgroundColor = midColor;
      cell.style.color = midColor;
      setTimeout(() => {
        cell.style.backgroundColor = lastColor;
        cell.style.color = lastColor;

        const [i, j] = getCellPosition(cell);
        let idx = i * COLCOUNT + j;
        if (charArrayIdx[idx] == 1) {
          whiteCellCount++;
          charArrayIdx[idx]++;
        }

        if (mode<4) {
            if (whiteCellCount < totalCharCount) {
            changeAdjacentCellsColor(i, j, seconds + Math.random() * 1, mode+1);
            }
        }

        if (whiteCellCount >= totalCharCount) {
          //clearInterval(timerInterval);
          //location.reload();
        }
      }, seconds * 1);
    }

    async function changeAdjacentCellsColor(row, col, delay, mode) {
      if (whiteCellCount >= totalCharCount) return;

      const adjacentCells = [
        [row - 1, col], [row + 1, col],
        [row, col - 1], [row, col + 1],
        [row - 1, col - 1], [row - 1, col + 1],
        [row + 1, col - 1], [row + 1, col + 1]
      ].filter(([r, c]) => r >= 0 && r < ROWCOUNT && c >= 0 && c < COLCOUNT);

      
      for (let k=0; k<adjacentCells.length; k++) {
        let y = adjacentCells[k][0];
        let x = adjacentCells[k][1];
        let idx = parseInt(y * COLCOUNT + x);
        const cell = grid.children[idx];
        const r = Math.random();
        if (r<0.3 && (cell.style.color!=lastColor)) { //(cell.style.color!=midColor && cell.style.color!=lastColor)
          const randomDuration = getRandomDuration();
           changeColor(cell, randomDuration, mode);
        }

      }
    
/*
      await Promise.all(adjacentCells.map(async ([i, j]) => {
        if (grid.children[i * COLCOUNT + j]) {
          const cell = grid.children[i * COLCOUNT + j];
          cell.style.backgroundColor = lastColor;
          cell.style.color = lastColor;
          await new Promise(resolve => setTimeout(resolve, delay * 10)); // 지연 시간을 줄임

          cell.style.backgroundColor = lastColor;
          cell.style.color = lastColor;

          let idx = i * COLCOUNT + j;
          if (charArrayIdx[idx] == 1) {
            whiteCellCount++;
            charArrayIdx[idx]++;
          }
          if (whiteCellCount < totalCharCount) {
            await changeAdjacentCellsColor(i, j, delay); // 지연 시간 유지
          }

          if (whiteCellCount >= totalCharCount) {
            clearInterval(timerInterval);
            location.reload();
          }
        }
      }));
      */
    }

    // 이벤트 핸들러 예시 (클릭 시)
    grid.addEventListener('click', async (event) => {
      let target = event.target;
      let index = Array.from(grid.children).indexOf(target);

      if (index !== -1) {
        let i = Math.floor(index / COLCOUNT);
        let j = index % COLCOUNT;

        await changeAdjacentCellsColor(i, j, 1);
      }
    });



    function initializeGrid() {
      grid.innerHTML = ''; // 기존의 격자를 비웁니다.
      for (let i = 0; i < ROWCOUNT; i++) { //Y
        for (let j = 0; j < COLCOUNT; j++) { //X
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.style.backgroundColor = baseColor; //글자가 안써진 칸
          let idx = i * COLCOUNT + j;
          charArrayIdx[i * COLCOUNT + j] = 0;
          cell.addEventListener('click', () => {
            if (charArrayIdx[idx] == 1) {
              if (cell.style.backgroundColor != baseColor) {
                cell.style.backgroundColor = baseColor;
                console.log("clickedN = " + idx);
                if (isFirstClick) {
                  changeColor(cell, 10, 1); // 최초 클릭 칸
                  isFirstClick = false;
                } else {
                  const randomDuration = getRandomDuration();
                  changeColor(cell, randomDuration, 1); // 나머지 칸들
                }
              }
            }
            cell.removeEventListener('click', () => { console.log("removed"); }, false);
          });
          grid.appendChild(cell);
        }
      }
    }


    initializeGrid();

    function shuffleSpecificCharacters() {
      
      const specificCharacters1 = [
        {
          rowStart: 1, rowEnd: 6, columnStart: 7, columnEnd: 50, text:
            `네가 읽은 문장들은 너의 것일까 네가 말한 문장들이 너의 것일까 `
        },
        {
          rowStart: 2, rowEnd: 7, columnStart: 10, columnEnd: 50, text:
            `김한민이 쓴 책 책섬에서 직접 인용 일부 변형 `
        },
        {
          rowStart: 1, rowEnd: 6, columnStart: 7, columnEnd: 50, text:
            `비행기 날아라 날아라 하하 너는 누구냐 김지영씨 `
        },
        {
          rowStart: 2, rowEnd: 7, columnStart: 10, columnEnd: 50, text:
            `김한민 바보 `
        },
        {
          rowStart: 1, rowEnd: 6, columnStart: 7, columnEnd: 50, text:
            `잘생긴 사람 다 죽어라 잘생긴 사람 다 죽어라 `
        },
        {
          rowStart: 2, rowEnd: 7, columnStart: 10, columnEnd: 50, text:
            `잘생긴 사람 다 죽어라 `
        },
      ];
      
      let tmpi = parseInt(Math.random()*2.999); //세트의 개수에 맞춰서 4세트면 3.9999 
      tmpi = tmpi*2;

      const specificCharacters = specificCharacters1.slice(tmpi, tmpi+2);
      
      for (let i = 0; i < ROWCOUNT; i++) { //Y
        for (let j = 0; j < COLCOUNT; j++) { //X
          const cell = grid.children[i * COLCOUNT + j];
          charArrayIdx[i * COLCOUNT + j] = 0;
          cell.textContent = '';
        }
      }

      specificCharacters.forEach(characterInfo => {
        const { rowStart, rowEnd, columnStart, columnEnd, text } = characterInfo;
        for (let row = rowStart; row <= rowEnd; row++) {
          for (let column = columnStart; column <= columnEnd; column++) {
            const specificCell = grid.children[row * COLCOUNT + column];
            let charX = parseInt(column - columnStart);
            let charY = parseInt(row - rowStart);
            let charIdx = charY * parseInt(columnEnd - columnStart) + charX;
            if (charIdx >= text.length - 1) continue;

            specificCell.textContent = text[charIdx];
            specificCell.style.color = 'black';
            specificCell.style.height = 20; // 셀 높이를 20으로 설정
            if (text[charIdx] != " " && text[charIdx] != "\n" && text[charIdx] != "\t" && text[charIdx] != 32 && text[charIdx] != 160) {
              specificCell.style.backgroundColor = baseColor; //글자가 들어간 셀 색깔
              charArrayIdx[row * COLCOUNT + column] = 1;
              totalCharCount++;
            }
          }
        }
      });
    }

    shuffleSpecificCharacters();

    const recognition = new webkitSpeechRecognition();
    recognition.continuous = false;
    recognition.interimResults = false;
    recognition.maxAlternatives = 10;
    recognition.lang = 'ko-KR';
    recognition.audioStartTimeout = 0;
    recognition.audioEndTimeout = 0;

    function allTextWhite() {
      const cells = Array.from(grid.children);
      for (let cell of cells) {
        if (cell.textContent.trim() && cell.style.color !== lastColor) {
          return false;
        }
      }
      return true;
    }

    recognition.onresult = function (event) {
      const interimTranscript = event.results[0][0].transcript;
      const finalTranscript = event.results[0].isFinal ? interimTranscript : '';

      for (let i = 0; i < finalTranscript.length; i++) {
        const char = finalTranscript.charAt(i);
        for (let y = 0; y < ROWCOUNT; y++) { //Y
          for (let x = 0; x < COLCOUNT; x++) { //X
            const idx = parseInt(y * COLCOUNT + x);
            const specificCell = grid.children[idx];
            const charinner = specificCell.textContent;
            if (charArrayIdx[idx]==1 && charinner.trim()==char.trim()) {
              console.log("checked:"+charinner.trim());
              if (isFirstClick) {
                changeColor(specificCell, 1, 1); // 최초 클릭 칸
                isFirstClick = false;
              } else {
                const randomDuration = getRandomDuration();
                changeColor(specificCell, randomDuration, 1); // 나머지 칸들
              }
            }

          }
        }
      }

      //recognition.start();

      /* // 24.06.24 10:52
      for (let i = 0; i < finalTranscript.length; i++) {
        if (Math.random() <= 0.1) { // 10% 확률로 이벤트 발생
          const char = finalTranscript.charAt(i);

          const randomIndex = Math.floor(Math.random() * grid.children.length);
          const cell = grid.children[randomIndex];
          if (isFirstClick) {
            changeColor(cell, 1); // 최초 클릭 칸
            isFirstClick = false;
          } else {
            const randomDuration = getRandomDuration();
            changeColor(cell, randomDuration); // 나머지 칸들
          }

          // 주변 셀들에 연쇄적으로 이벤트 발생
          const neighbors = getNeighbors(cell);
          neighbors.forEach(neighbor => {
            if (charArrayIdx[Array.from(grid.children).indexOf(neighbor)] == 1) {
              changeColor(neighbor, randomDuration);
            }
          });
        }
      }
      */

      /*
      if (allTextLastColor()) {
        clearInterval(timerInterval);
        alert('All text is now lastColor!');
        location.reload();
      }
        */
    };

    function allTextLastColor() {
      const cells = Array.from(grid.children);
      for (let cell of cells) {
        if (cell.textContent.trim() && cell.style.color !== lastColor) {
          return false;
        }
      }
      return true;
    }


    recognition.onerror = (event) => {
      const error = event.error;

      switch (error) {
        case 'no-speech':
          break;
        case 'audio-capture':
          break;
        case 'not-allowed':
          break;
        default:
      }
    };

    recognition.onend = () => {
      recognition.start();
      console.log("recognition restarted");
    };

    // 음성 인식 시작
    recognition.start();

    const timer = document.getElementById('timer');
    let seconds = 0;
    const timerInterval = setInterval(() => {
      seconds++;

      if (seconds >= 86400) {
        seconds = 0;
      }
      timer.textContent = seconds;
      if (whiteCellCount >= totalCharCount) {
        clearInterval(timerInterval);
        location.reload(true);
        //location.href="index1.html";
      }
    }, 1000);

  </script>
</body>

</html>